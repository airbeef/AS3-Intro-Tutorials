package {	import flash.display.MovieClip;	import flash.geom.Point;		public class CollisionB	{		public function CollisionB()		{		}		static public function block(objectA:Object,objectB:Object):void		{			var objectA_Halfwidth = objectA.width / 2;			var objectA_Halfheight = objectA.height / 2;			var objectB_Halfwidth = objectB.width / 2;			var objectB_Halfheight = objectB.height / 2;			var dx = objectB.x - objectA.x;			var ox = objectB_Halfwidth + objectA_Halfwidth - Math.abs(dx);			if (0 < ox)			{				var dy = objectA.y - objectB.y;				var oy = objectB_Halfheight + objectA_Halfheight - Math.abs(dy);				if (0 < oy)				{					if (ox < oy)					{						if (dx < 0)						{							ox *= -1;							oy=0;						}						else						{							oy=0;						}					}					else					{						if (dy<0)						{							ox=0;							oy*=-1;						}						else						{							ox=0;						}					}					objectA.x-=ox;					objectA.y+=oy;				}			}		}		static public function platform_BlockRectangles(objectA:Object,objectB:Object):void		{			//This function requires the following setter properties in objectA:			// _objectIsOnGround:Boolean, vx:Number, vy:Number			var objectA_Halfwidth=objectA.width/2;			var objectA_Halfheight=objectA.height/2;			var objectB_Halfwidth=objectB.width/2;			var objectB_Halfheight=objectB.height/2;			var dx=objectB.x-objectA.x;			var ox=objectB_Halfwidth+objectA_Halfwidth-Math.abs(dx);			if (0<ox)			{				var dy=objectA.y-objectB.y;				var oy=objectB_Halfheight+objectA_Halfheight-Math.abs(dy);				if (0<oy)				{					if (ox<oy)					{						if (dx<0)						{							ox*=-1;							oy=0;						}						else						{							oy=0;						}						//Dampen horizontal velocity						objectA.vx=0;					}					else					{						if (dy<0)						{							ox=0;							oy*=-1;							objectA.isOnGround=true;						}						else						{							ox=0;						}						//Dampen vertical velocity						objectA.vy=0;					}					objectA.x-=ox;					objectA.y+=oy;				}			}		}				static public function rectangleAndRectangle(objectA:MovieClip,objectB:MovieClip,bounce:Number,friction:Number):void		{			//This function requires the following setter properties in objectA:			// _objectIsOnGround:Boolean, vx:Number, vy:Number			var objectA_Halfwidth:Number;			var objectA_Halfheight:Number;			var objectA_X:Number;			var objectA_Y:Number						if(objectA.collisionArea != null)			{				objectA_Halfwidth = objectA.collisionArea.width / 2;			    objectA_Halfheight = objectA.collisionArea.height / 2;				var objectA_Position:Point = new Point(objectA.collisionArea.x, objectA.collisionArea.y);            	objectA_X = objectA.localToGlobal(objectA_Position).x;				objectA_Y = objectA.localToGlobal(objectA_Position).y;			}			else			{				objectA_Halfwidth = objectA.width / 2;			    objectA_Halfheight = objectA.height / 2;				objectA_X = objectA.x;				objectA_Y = objectA.y;			}			var objectB_Halfwidth:Number = objectB.width / 2;			var objectB_Halfheight:Number = objectB.height / 2;			var dx:Number = objectB.x - objectA_X;			var ox:Number = objectB_Halfwidth + objectA_Halfwidth - Math.abs(dx);			if (0 < ox)			{				var dy:Number = objectA_Y - objectB.y;				var oy:Number = objectB_Halfheight + objectA_Halfheight - Math.abs(dy);				if (0<oy)				{					if (ox<oy)					{						if (dx<0)						{							//Right;							//ox is unchanged							oy = 0;							dx = 1;							dy = 0							CollisionB.resolveCollision(ox, oy, dx, dy, objectA, objectB, bounce, friction);						}						else						{							//Left							ox *= -1;							oy = 0;							dx = -1;							dy = 0							CollisionB.resolveCollision(ox, oy, dx, dy, objectA, objectB, bounce, friction);						}					}					else					{						if (dy<0)						{							//Top							ox = 0;							oy *= -1;							dx = 0;							dy = -1;							CollisionB.resolveCollision(ox, oy, dx, dy, objectA, objectB, bounce, friction);						}						else						{							//Bottom							ox = 0;							//oy is unchanged							dx = 0;							dy = 1;							CollisionB.resolveCollision(ox, oy, dx, dy, objectA, objectB, bounce, friction);						}					}				}			}		}		//General purpose method for testing Axis-based collisions. Returns true or False		static public function test(objectA:Object,objectB:Object):Boolean		{			var objectA_Halfwidth=objectA.width/2;			var objectA_Halfheight=objectA.height/2;			var objectB_Halfwidth=objectB.width/2;			var objectB_Halfheight=objectB.height/2;			var dx=objectB.x-objectA.x;			var ox=objectB_Halfwidth+objectA_Halfwidth-Math.abs(dx);			if (0<ox)			{				var dy=objectA.y-objectB.y;				var oy=objectB_Halfheight+objectA_Halfheight-Math.abs(dy);				if (0<oy)				{					return true;				}			}			else			{				return false;			}			return false;		}		//EXPERIMENTAL! I'm working on this for chapter 9, it won't be included in the final version of this file.		static public function CircleAndSquare(objectA:Object,objectB:Object, bounce:Number, friction:Number)		{			//check to see whether the object has a collisionArea object defined			var objectA_radius:Number			if(objectA.collisionArea != null)			{				objectA_radius = objectA.collisionArea.width/2;			}			else			{				objectA_radius = objectA.width/2;			}			//trace("Name: " + objectA.collisionArea.name + "Radius: " + objectA_radius);			var objectB_Halfwidth:Number = objectB.width/2;			var objectB_Halfhieght:Number = objectB.height/2;			//The distance between the objects on the x axis			var dx:Number = objectA.x - objectB.x //+(objectA.width - objectA.collisionArea.width);			//The amount of overlap between the objects on the x axis			var ox:Number = objectB_Halfwidth + objectA_radius -Math.abs(dx);			//The distance between the objects on the y axis			var dy:Number = objectA.y-objectB.y //+(objectA.height - objectA.collisionArea.height);			//The amount of overlap between the objects on the y axis			var oy:Number = objectB_Halfhieght + objectA_radius -Math.abs(dy);						if (0<ox)			{				if (0<oy)				{					//A collision might be occuring					//Find out the voronoi region of the circle's center					var oH:Number = 0;					var oV:Number = 0;					if(dx < -objectB_Halfwidth)					{						//The circle is to the left of the square						oH = -1;					}						else if(objectB_Halfwidth < dx)					{						//The circle is to the right of the square						oH = 1;					}										if(dy < -objectB_Halfhieght)					{						//The circle is above the square						oV = -1;					}					else if(objectB_Halfhieght < dy)					{						//The circle is below the square						oV = 1;					}					//Find the amount of overlap					if (oH==0)					{						if (oV==0)						{							//A collision is occuring							if (ox<oy)							{								//Overlap is least on the x axis								if (dx<0)								{									//dx is -1									CollisionB.resolveCollision(-ox,0,-1,0,objectB,objectA,bounce,friction);								}								else								{									//dx is 1									CollisionB.resolveCollision(ox,0,1,0,objectB,objectA,bounce,friction);								}							}							else							{								//Overlap is least on the y axis								if (dy<0)								{									//dy is -1									CollisionB.resolveCollision(0,-oy,0,-1,objectB,objectA,bounce,friction);								}								else								{									//dy is 1									CollisionB.resolveCollision(0,oy,0,1,objectB,objectA,bounce,friction);								}							}						}						else						{							CollisionB.resolveCollision(0,oy*oV,0,oV,objectB,objectA,bounce,friction);						}					}					else if (oV==0)					{						CollisionB.resolveCollision(ox*oH,0,oH,0,objectB,objectA,bounce,friction);					}					else					{						//Collision along diagonal						//The diagonal vertex						var vertexX:Number = objectB.x+oH*objectB.width/2;						var vertexY:Number = objectB.y+oV*objectB.width/2;						dx = objectA.x-vertexX;						dy = objectA.y-vertexY;						var len:Number = Math.sqrt(dx*dx+dy*dy);						var pen:Number = objectA_radius-len;						if (0<pen)						{							//the vertex is in the circle							if (len==0)							{								//Project out at 45 degrees								dx=oH/Math.SQRT2;								dy=oV/Math.SQRT2;							}							else							{								dx/=len;								dy/=len;							}							CollisionB.resolveCollision(dx*pen,dy*pen,dx,dy,objectB,objectA,bounce,friction);						}					}				}			}		}				static public function resolveCollision(ox, oy, dx, dy, objectA, objectB, bounce, friction)		{			var parallelComponent:Number;			var normalizedXVelocity:Number;			var normalizedYVelocity:Number;			var perpedicularXComponent:Number;			var perpedicularYComponent:Number;			var bounceX:Number;			var bounceY:Number;			var frictionX:Number;			var frictionY:Number;			var vx:Number;			var vy:Number;						if(objectA.vx != null)			{				vx = objectA.vx; 			}			else			{				trace("Warning: " + objectA.name + " does not have a vx property.")				vx = 0;			}			if(objectA.vy != null)			{				vy = objectA.vy; 			}			else			{				trace("Warning: " + objectA.name + " does not have a vy property.")				vy = 0;			}			//Find  the parallel component			parallelComponent = vx * dx + vy * dy;			//Normalize the velocity (find it's direction, either 1 or -1)			normalizedXVelocity = parallelComponent * dx;			normalizedYVelocity = parallelComponent * dy;			//Find the perpendicular component			perpedicularXComponent = vx - normalizedXVelocity;			perpedicularYComponent = vy - normalizedYVelocity;			//Apply collision forces if the object if the object is moving into a collision			if (parallelComponent < 0)			{				frictionX = perpedicularXComponent * friction;				frictionY = perpedicularYComponent * friction;				bounceX = normalizedXVelocity * bounce;				bounceY = normalizedYVelocity * bounce;			}			else			{				//Prevent forces from being applied if the object is				//moving out of a collision				bounceX = 0;				bounceY = 0;				frictionX = 0;				frictionY = 0;			}			//Move objectA out of collision and apply forces			objectA.vx += ox - friction;			objectA.vy += oy - friction;			objectA.x += ox;			objectA.y += oy;			objectA.bounceX = bounceX;			objectA.bounceY = bounceY;						//Add this code if you need to detect whether the object is			//on a platform. Make sure that the Player class has a getter and			//setter to accept and change the isOnGround value:			if(dy == -1)			{				if(objectA.isOnGround != null)				{					objectA.isOnGround=true;				}			}		}	}}